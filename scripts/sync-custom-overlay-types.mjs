#!/usr/bin/env node
import { readFileSync, writeFileSync, mkdirSync, copyFileSync } from 'node:fs';
import { resolve, dirname } from 'node:path';

const projectRoot = resolve(process.cwd());
const templatePath = resolve(projectRoot, 'docs/custom-overlays/custom-overlays.d.ts');
const outputPath = resolve(projectRoot, 'dist/custom-overlays.d.ts');
const activityTypesPath = resolve(projectRoot, 'dist/activity.types.d.ts');
const variablesTypesPath = resolve(projectRoot, 'dist/variables.types.d.ts');
const docsDir = resolve(projectRoot, 'docs/custom-overlays');
const distDocsDir = resolve(projectRoot, 'dist/custom-overlays');

const sections = [
  { name: 'LumiaAlertValues', sourcePath: activityTypesPath },
  { name: 'SystemVariables', sourcePath: variablesTypesPath },
];

const extraFiles = [
  'custom-overlays-documentation.md',
  'custom-overlays-cheatsheet.md',
  'custom-overlays-examples.md',
  'custom-overlays-alerts.d.ts',
];

function extractEnumBlock(fileContent, enumName) {
  const marker = `export declare enum ${enumName}`;
  const start = fileContent.indexOf(marker);
  if (start === -1) {
    throw new Error(`Could not find enum ${enumName} in source file.`);
  }
  const braceStart = fileContent.indexOf('{', start);
  if (braceStart === -1) {
    throw new Error(`Could not find opening brace for enum ${enumName}.`);
  }

  let index = braceStart + 1;
  let depth = 1;
  while (depth > 0 && index < fileContent.length) {
    const char = fileContent[index];
    if (char === '{') depth += 1;
    else if (char === '}') depth -= 1;
    index += 1;
  }

  if (depth !== 0) {
    throw new Error(`Unbalanced braces while parsing enum ${enumName}.`);
  }

  const end = index;
  const block = fileContent.slice(start, end).trimEnd();
  return `${block}\n`;
}

function replaceSection(targetContent, sectionName, newContent) {
  const startToken = `// <auto-generated-start name="${sectionName}" />`;
  const endToken = `// <auto-generated-end name="${sectionName}" />`;

  const startIdx = targetContent.indexOf(startToken);
  const endIdx = targetContent.indexOf(endToken);

  if (startIdx === -1 || endIdx === -1) {
    throw new Error(`Could not find markers for section ${sectionName}.`);
  }
  if (endIdx < startIdx) {
    throw new Error(`End marker appears before start marker for section ${sectionName}.`);
  }

  const before = targetContent.slice(0, startIdx + startToken.length);
  const after = targetContent.slice(endIdx);
  const replacement = `\n${newContent}\n`;

  return `${before}${replacement}${after}`;
}

function sync() {
  let templateContent = readFileSync(templatePath, 'utf8');

  for (const { name, sourcePath } of sections) {
    const sourceContent = readFileSync(sourcePath, 'utf8');
    const enumBlock = extractEnumBlock(sourceContent, name);
    templateContent = replaceSection(templateContent, name, enumBlock);
  }

  writeFileSync(templatePath, templateContent, 'utf8');

  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, templateContent, 'utf8');

  mkdirSync(distDocsDir, { recursive: true });
  copyFileSync(templatePath, resolve(distDocsDir, 'custom-overlays.d.ts'));

  for (const file of extraFiles) {
    const source = resolve(docsDir, file);
    const target = resolve(distDocsDir, file);
    copyFileSync(source, target);
  }

  console.log('Custom overlay documentation synced to dist/.');
}

try {
  sync();
} catch (error) {
  console.error(error instanceof Error ? error.message : error);
  process.exitCode = 1;
}
